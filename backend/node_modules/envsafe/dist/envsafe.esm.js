function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var InvalidEnvError = /*#__PURE__*/function (_TypeError) {
  _inheritsLoose(InvalidEnvError, _TypeError);

  function InvalidEnvError(message) {
    var _this;

    _this = _TypeError.call(this, message) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this), InvalidEnvError.prototype);
    return _this;
  }

  return InvalidEnvError;
}( /*#__PURE__*/_wrapNativeSuper(TypeError));
var invalidEnvError = function invalidEnvError(type, input) {
  return new InvalidEnvError("Invalid " + type + " input: \"" + input + "\"");
};
var MissingEnvError = /*#__PURE__*/function (_ReferenceError) {
  _inheritsLoose(MissingEnvError, _ReferenceError);

  function MissingEnvError(message) {
    var _this2;

    _this2 = _ReferenceError.call(this, message) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this2), MissingEnvError.prototype);
    return _this2;
  }

  return MissingEnvError;
}( /*#__PURE__*/_wrapNativeSuper(ReferenceError));

var inspectables = ['length', 'inspect', 'hasOwnProperty', 'toJSON', // jest stuff:
'asymmetricMatch', 'nodeType', '$$typeof', 'constructor', '@@__IMMUTABLE_ITERABLE__@@', '@@__IMMUTABLE_RECORD__@@', '_isMockFunction', // For libs that use `then` checks to see if objects are Promises
// https://github.com/af/envalid/issues/74
'then', // For usage with TypeScript esModuleInterop flag
'__esModule'];
function freezeObject(envObj, env) {
  var frozen = Object.freeze ? Object.freeze(envObj) : envObj;
  return global.Proxy ? new Proxy(frozen, {
    get: function get(_target, name) {
      // These checks are needed because calling console.log on a
      // proxy that throws crashes the entire process. This whitelists
      // the necessary properties for `console.log(frozen)`, `frozen.length`,
      // `frozen.hasOwnProperty('string')` to work.
      if (typeof name !== 'string' || inspectables.includes(name)) {
        return frozen[name];
      }

      var varExists = frozen.hasOwnProperty(name);

      if (!varExists) {
        if (env.hasOwnProperty(name)) {
          throw new ReferenceError("[envsafe] Env var " + String(name) + " was accessed but not validated. This var is set in the environment; please add an envsafe validator for it.");
        }

        throw new ReferenceError("[envsafe] Env var \"" + String(name) + "\" not found");
      }

      return frozen[name];
    }
  }) : frozen;
}

function defaultReporterText(_ref) {
  var errors = _ref.errors;
  var keys = Object.keys(errors);
  var invalids = [];
  var missing = [];

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    var err = errors[key];

    if (err instanceof MissingEnvError) {
      missing.push("    " + key + ": " + (err.message || 'required'));
    } else {
      invalids.push("    " + key + ": " + (err.message || 'invalid'));
    }
  }

  if (invalids.length) {
    invalids.unshift('❌ Invalid environment variables:');
  }

  if (missing.length) {
    missing.unshift('💨 Missing environment variables:');
  }

  var output = ['========================================'].concat(invalids, missing, ['========================================']);
  return output.join('\n');
}
function defaultReporter(opts) {
  var _window;

  var text = defaultReporterText(opts);
  console.error(text);

  if (typeof window !== 'undefined' && ((_window = window) == null ? void 0 : _window.alert)) {
    window.alert(text);
  }

  throw new TypeError(text);
}

function getValueOrThrow(_ref) {
  var env = _ref.env,
      validator = _ref.validator,
      key = _ref.key;
  var usingDevDefault = env.NODE_ENV !== 'production';
  var _validator$allowEmpty = validator.allowEmpty,
      allowEmpty = _validator$allowEmpty === void 0 ? false : _validator$allowEmpty;
  /**
   * Function to see if the value isn't empty or undefined
   */

  function isSet(value) {
    if (!allowEmpty) {
      return value !== undefined && value !== '';
    }

    return value !== undefined;
  }

  var input = isSet(validator.input) ? validator.input : env[key];

  if (usingDevDefault && !isSet(input) && isSet(validator.devDefault)) {
    input = validator.devDefault;
  }

  if (!isSet(input) && isSet(validator["default"])) {
    input = validator["default"];
  }

  if (!isSet(input)) {
    var errMessage = "Missing value";

    if (!validator.allowEmpty) {
      errMessage += ' or empty string';
    }

    throw new MissingEnvError(errMessage);
  }

  var output = validator._parse(input);

  if (validator.choices && !validator.choices.includes(output)) {
    throw new InvalidEnvError("Value \"" + output + "\" not in choices [" + validator.choices + "]");
  }

  return output;
}

function envsafe(validators, _temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      _ref2$reporter = _ref2.reporter,
      reporter = _ref2$reporter === void 0 ? defaultReporter : _ref2$reporter,
      _ref2$env = _ref2.env,
      env = _ref2$env === void 0 ? process.env : _ref2$env,
      _ref2$strict = _ref2.strict,
      strict = _ref2$strict === void 0 ? false : _ref2$strict;

  var errors = {};
  var output = {};

  for (var key in validators) {
    var validator = validators[key];

    try {
      var resolved = getValueOrThrow({
        env: env,
        validator: validator,
        key: key
      });
      output[key] = resolved;
    } catch (err) {
      errors[key] = err;
    }
  }

  if (Object.keys(errors).length) {
    reporter({
      errors: errors,
      output: output,
      env: env
    });
  }

  return strict ? freezeObject(output, env) : output;
}

var EMAIL_REGEX = /^[^@\s]+@[^@\s]+\.[^@\s]+$/; // intentionally non-exhaustive

function makeValidator(parser) {
  return function (spec) {
    if (spec === void 0) {
      spec = {};
    }

    return _extends({}, spec, {
      _parse: parser
    });
  };
}
var bool = /*#__PURE__*/makeValidator(function (input) {
  switch (input) {
    case true:
    case 'true':
    case 't':
    case '1':
      return true;

    case false:
    case 'false':
    case 'f':
    case '0':
      return false;

    default:
      throw invalidEnvError('str', input);
  }
});
var str = /*#__PURE__*/makeValidator(function (input) {
  if (typeof input !== 'string') {
    throw invalidEnvError('str', input);
  }

  return input;
});
var email = /*#__PURE__*/makeValidator(function (input) {
  if (!EMAIL_REGEX.test(input)) {
    throw invalidEnvError('email', input);
  }

  return input;
});
var num = /*#__PURE__*/makeValidator(function (input) {
  var coerced = +input;

  if (Number.isNaN(coerced)) {
    throw invalidEnvError('num', input);
  }

  return coerced;
});
var port = /*#__PURE__*/makeValidator(function (input) {
  var coerced = +input;

  if (Number.isNaN(coerced) || "" + coerced !== "" + input || coerced % 1 !== 0 || coerced < 1 || coerced > 65535) {
    throw invalidEnvError('port', input);
  }

  return coerced;
});
var url = /*#__PURE__*/makeValidator(function (input) {
  try {
    new URL(input); // validate url

    return input;
  } catch (_) {
    throw invalidEnvError('url', input);
  }
});
var json = /*#__PURE__*/makeValidator(function (input) {
  try {
    if (typeof input !== 'string') {
      return input;
    }

    return JSON.parse(input);
  } catch (e) {
    throw invalidEnvError('json', input);
  }
});

export { InvalidEnvError, MissingEnvError, bool, defaultReporter, defaultReporterText, email, envsafe, freezeObject, invalidEnvError, json, makeValidator, num, port, str, url };
//# sourceMappingURL=envsafe.esm.js.map
