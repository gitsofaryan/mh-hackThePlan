{"version":3,"file":"envsafe.cjs.production.min.js","sources":["../src/errors.ts","../src/freezeObject.ts","../src/reporter.ts","../src/envsafe.ts","../src/validators.ts"],"sourcesContent":["export class InvalidEnvError extends TypeError {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, InvalidEnvError.prototype);\n  }\n}\n\nexport const invalidEnvError = (type: string, input: unknown) =>\n  new InvalidEnvError(`Invalid ${type} input: \"${input}\"`);\n\nexport class MissingEnvError extends ReferenceError {\n  constructor(message?: string) {\n    super(message);\n\n    Object.setPrototypeOf(this, MissingEnvError.prototype);\n  }\n}\n","import { Environment } from './types';\n\nconst inspectables = [\n  'length',\n  'inspect',\n  'hasOwnProperty',\n  'toJSON',\n\n  // jest stuff:\n  'asymmetricMatch',\n  'nodeType',\n  '$$typeof',\n  'constructor',\n  '@@__IMMUTABLE_ITERABLE__@@',\n  '@@__IMMUTABLE_RECORD__@@',\n  '_isMockFunction',\n\n  // For libs that use `then` checks to see if objects are Promises\n  // https://github.com/af/envalid/issues/74\n  'then',\n  // For usage with TypeScript esModuleInterop flag\n  '__esModule',\n];\n\nexport function freezeObject<TCleanEnv extends Record<string, any>>(\n  envObj: TCleanEnv,\n  env: Environment,\n): Readonly<TCleanEnv> {\n  const frozen = Object.freeze ? Object.freeze(envObj) : envObj;\n\n  return global.Proxy\n    ? new Proxy(frozen, {\n        get(_target, name) {\n          // These checks are needed because calling console.log on a\n          // proxy that throws crashes the entire process. This whitelists\n          // the necessary properties for `console.log(frozen)`, `frozen.length`,\n          // `frozen.hasOwnProperty('string')` to work.\n\n          if (typeof name !== 'string' || inspectables.includes(name)) {\n            return (frozen as any)[name];\n          }\n\n          const varExists = frozen.hasOwnProperty(name);\n          if (!varExists) {\n            if (env.hasOwnProperty(name)) {\n              throw new ReferenceError(\n                `[envsafe] Env var ${String(\n                  name,\n                )} was accessed but not validated. This var is set in the environment; please add an envsafe validator for it.`,\n              );\n            }\n\n            throw new ReferenceError(\n              `[envsafe] Env var \"${String(name)}\" not found`,\n            );\n          }\n\n          return (frozen as any)[name];\n        },\n      })\n    : frozen;\n}\n","import { MissingEnvError } from './errors';\nimport { ReporterOpts } from './types';\n\nexport function defaultReporterText<TCleanEnv>({\n  errors,\n}: ReporterOpts<TCleanEnv>) {\n  const keys = Object.keys(errors);\n\n  const invalids: string[] = [];\n  const missing: string[] = [];\n\n  for (const key of keys) {\n    const err = errors[key];\n    if (err instanceof MissingEnvError) {\n      missing.push(`    ${key}: ${err.message || 'required'}`);\n    } else {\n      invalids.push(`    ${key}: ${err.message || 'invalid'}`);\n    }\n  }\n  if (invalids.length) {\n    invalids.unshift('‚ùå Invalid environment variables:');\n  }\n  if (missing.length) {\n    missing.unshift('üí® Missing environment variables:');\n  }\n\n  const output: string[] = [\n    '========================================',\n    ...invalids,\n    ...missing,\n    '========================================',\n  ];\n\n  return output.join('\\n');\n}\n\nexport function defaultReporter<TCleanEnv>(opts: ReporterOpts<TCleanEnv>) {\n  const text = defaultReporterText(opts);\n  console.error(text);\n\n  if (typeof window !== 'undefined' && window?.alert) {\n    window.alert(text);\n  }\n\n  throw new TypeError(text);\n}\n","import { InvalidEnvError, MissingEnvError } from './errors';\nimport { freezeObject } from './freezeObject';\nimport { defaultReporter } from './reporter';\nimport {\n  EnvsafeOpts,\n  Environment,\n  Errors,\n  ValidatorSpec,\n  Validators,\n} from './types';\n\nfunction getValueOrThrow<TValue>({\n  env,\n  validator,\n  key,\n}: {\n  env: Environment;\n  validator: ValidatorSpec<TValue>;\n  key: string;\n}): TValue {\n  const usingDevDefault = env.NODE_ENV !== 'production';\n  const { allowEmpty = false } = validator;\n\n  /**\n   * Function to see if the value isn't empty or undefined\n   */\n  function isSet(value: string | TValue | undefined): value is string | TValue {\n    if (!allowEmpty) {\n      return value !== undefined && value !== '';\n    }\n    return value !== undefined;\n  }\n\n  let input: string | TValue | undefined = isSet(validator.input)\n    ? validator.input\n    : env[key];\n\n  if (usingDevDefault && !isSet(input) && isSet(validator.devDefault)) {\n    input = validator.devDefault;\n  }\n  if (!isSet(input) && isSet(validator.default)) {\n    input = validator.default;\n  }\n\n  if (!isSet(input)) {\n    let errMessage = `Missing value`;\n    if (!validator.allowEmpty) {\n      errMessage += ' or empty string';\n    }\n    throw new MissingEnvError(errMessage);\n  }\n\n  const output = validator._parse(input);\n\n  if (validator.choices && !validator.choices.includes(output)) {\n    throw new InvalidEnvError(\n      `Value \"${output}\" not in choices [${validator.choices}]`,\n    );\n  }\n\n  return output;\n}\n\nexport function envsafe<TCleanEnv>(\n  validators: Validators<TCleanEnv>,\n  {\n    reporter = defaultReporter,\n    env = process.env,\n    strict = false,\n  }: EnvsafeOpts<TCleanEnv> = {},\n): Readonly<TCleanEnv> {\n  const errors: Errors = {};\n  const output = {} as TCleanEnv;\n\n  for (const key in validators) {\n    const validator = validators[key];\n    try {\n      const resolved = getValueOrThrow({ env, validator, key });\n      output[key] = resolved;\n    } catch (err) {\n      errors[key] = err;\n    }\n  }\n\n  if (Object.keys(errors).length) {\n    reporter({ errors, output, env });\n  }\n\n  return strict ? freezeObject(output, env) : output;\n}\n","import { invalidEnvError } from './errors';\nimport { Spec, ValidatorSpec } from './types';\nconst EMAIL_REGEX = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/; // intentionally non-exhaustive\n\nexport function makeValidator<TValue>(\n  parser: (input: string | TValue) => TValue,\n): (spec?: Spec<TValue>) => ValidatorSpec<TValue> {\n  return (spec = {}) => {\n    return {\n      ...spec,\n      _parse: parser,\n    };\n  };\n}\n\nexport const bool = makeValidator<boolean>(input => {\n  switch (input) {\n    case true:\n    case 'true':\n    case 't':\n    case '1':\n      return true;\n    case false:\n    case 'false':\n    case 'f':\n    case '0':\n      return false;\n    default:\n      throw invalidEnvError('str', input);\n  }\n});\n\nexport const str = makeValidator<string>(input => {\n  if (typeof input !== 'string') {\n    throw invalidEnvError('str', input);\n  }\n  return input;\n});\n\nexport const email = makeValidator<string>(input => {\n  if (!EMAIL_REGEX.test(input)) {\n    throw invalidEnvError('email', input);\n  }\n  return input;\n});\n\nexport const num = makeValidator<number>(input => {\n  const coerced = +input;\n  if (Number.isNaN(coerced)) {\n    throw invalidEnvError('num', input);\n  }\n  return coerced;\n});\n\nexport const port = makeValidator<number>(input => {\n  const coerced = +input;\n  if (\n    Number.isNaN(coerced) ||\n    `${coerced}` !== `${input}` ||\n    coerced % 1 !== 0 ||\n    coerced < 1 ||\n    coerced > 65535\n  ) {\n    throw invalidEnvError('port', input);\n  }\n  return coerced;\n});\n\nexport const url = makeValidator<string>(input => {\n  try {\n    new URL(input); // validate url\n    return input;\n  } catch (_) {\n    throw invalidEnvError('url', input);\n  }\n});\n\nexport const json = makeValidator<unknown>(input => {\n  try {\n    if (typeof input !== 'string') {\n      return input;\n    }\n\n    return JSON.parse(input) as unknown;\n  } catch (e) {\n    throw invalidEnvError('json', input);\n  }\n});\n"],"names":["InvalidEnvError","message","Object","setPrototypeOf","prototype","TypeError","invalidEnvError","type","input","MissingEnvError","ReferenceError","inspectables","freezeObject","envObj","env","frozen","freeze","global","Proxy","get","_target","name","includes","hasOwnProperty","String","defaultReporterText","errors","invalids","missing","keys","key","err","push","length","unshift","join","defaultReporter","opts","text","console","error","window","_window","alert","getValueOrThrow","validator","usingDevDefault","NODE_ENV","allowEmpty","isSet","value","undefined","devDefault","errMessage","output","_parse","choices","EMAIL_REGEX","makeValidator","parser","spec","bool","str","email","test","num","coerced","Number","isNaN","port","url","URL","_","json","JSON","parse","e","validators","reporter","process","strict","resolved"],"mappings":"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"}